<?php

namespace App\Console\Commands;

use App\Console\Concerns\LogsIngestion;
use Illuminate\Console\Command;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Http;
use ZipArchive;

class IngestVulnerabilityAreas extends Command
{
    use LogsIngestion;

    protected $signature = 'ingest:vulnerability-areas
        {--year=2025 : Assessment year}
        {--file= : Path to local GeoJSON file (skips download)}';

    protected $description = 'Import police vulnerability area (utsatta områden) polygons from Polisen GeoJSON';

    private const GEOJSON_ZIP_URL = 'https://polisen.se/contentassets/1f86e17354294629b5b66559eef35972/uso_2025_geojson.zip';

    private const CATEGORY_MAP = [
        'Utsatt område' => 'utsatt',
        'Särskilt utsatt område' => 'sarskilt_utsatt',
    ];

    public function handle(): int
    {
        $year = (int) $this->option('year');

        $this->startIngestionLog('vulnerability', 'ingest:vulnerability-areas');
        $this->addStat('year', $year);

        $geojsonPath = $this->resolveGeojsonFile();
        if (! $geojsonPath) {
            $this->failIngestionLog('Could not obtain GeoJSON file');

            return self::FAILURE;
        }

        $this->info('Parsing GeoJSON file...');
        $geojson = json_decode(file_get_contents($geojsonPath), true);

        if (! $geojson || ! isset($geojson['features'])) {
            $this->error('Invalid GeoJSON structure.');
            $this->failIngestionLog('Invalid GeoJSON structure');

            return self::FAILURE;
        }

        $features = $geojson['features'];
        $total = count($features);
        $this->info("Found {$total} vulnerability area features.");

        // Detect CRS — Polisen uses EPSG:3006 (SWEREF99TM)
        $sourceSrid = 4326;
        if (isset($geojson['crs']['properties']['name'])) {
            $crsName = $geojson['crs']['properties']['name'];
            if (str_contains($crsName, '3006')) {
                $sourceSrid = 3006;
                $this->info('Detected EPSG:3006 (SWEREF99TM) — will reproject to WGS84.');
            }
        }

        // Mark previous assessments as not current
        DB::table('vulnerability_areas')
            ->where('is_current', true)
            ->update(['is_current' => false]);

        $imported = 0;

        DB::beginTransaction();

        try {
            foreach ($features as $feature) {
                $this->importFeature($feature, $year, $sourceSrid);
                $imported++;
            }

            DB::commit();
        } catch (\Throwable $e) {
            DB::rollBack();
            $this->error("Import failed: {$e->getMessage()}");
            $this->failIngestionLog($e->getMessage());

            return self::FAILURE;
        }

        $this->info("Imported {$imported} vulnerability areas.");

        // Compute DeSO overlap mapping
        $mappedDesos = $this->computeDesoMapping();

        $tierCounts = DB::table('vulnerability_areas')
            ->where('is_current', true)
            ->selectRaw('tier, COUNT(*) as cnt')
            ->groupBy('tier')
            ->pluck('cnt', 'tier');

        $this->info('Tier breakdown: '.json_encode($tierCounts));
        $this->info("DeSOs mapped to vulnerability areas: {$mappedDesos}");

        $this->processed = $total;
        $this->created = $imported;
        $this->addStat('tier_counts', $tierCounts);
        $this->addStat('desos_mapped', $mappedDesos);
        $this->completeIngestionLog();

        return self::SUCCESS;
    }

    private function resolveGeojsonFile(): ?string
    {
        if ($this->option('file')) {
            $path = $this->option('file');
            if (! file_exists($path)) {
                $this->error("File not found: {$path}");

                return null;
            }

            return $path;
        }

        $storageDir = storage_path('app/data/raw/polisen');
        if (! is_dir($storageDir)) {
            mkdir($storageDir, 0755, true);
        }

        $geojsonPath = $storageDir.'/uso_2025.geojson';
        if (file_exists($geojsonPath)) {
            $this->info('Using cached GeoJSON file.');

            return $geojsonPath;
        }

        $this->info('Downloading vulnerability area GeoJSON from Polisen...');
        $zipPath = $storageDir.'/uso_2025_geojson.zip';

        $response = Http::timeout(60)->get(self::GEOJSON_ZIP_URL);
        if (! $response->successful()) {
            $this->error('Failed to download GeoJSON zip.');

            return null;
        }

        file_put_contents($zipPath, $response->body());

        $zip = new ZipArchive;
        if ($zip->open($zipPath) !== true) {
            $this->error('Failed to open zip file.');

            return null;
        }

        $zip->extractTo($storageDir);
        $zip->close();

        if (! file_exists($geojsonPath)) {
            // Try to find the extracted file
            $files = glob($storageDir.'/*.geojson');
            if (count($files) > 0) {
                $geojsonPath = $files[0];
            } else {
                $this->error('No GeoJSON file found in zip.');

                return null;
            }
        }

        $this->info('Downloaded and extracted GeoJSON.');

        return $geojsonPath;
    }

    private function importFeature(array $feature, int $year, int $sourceSrid): void
    {
        $props = $feature['properties'] ?? [];
        $geometry = $feature['geometry'] ?? null;

        if (! $geometry) {
            return;
        }

        $name = $props['NAMN'] ?? 'Unknown';
        $kategori = $props['KATEGORI'] ?? '';
        $tier = self::CATEGORY_MAP[$kategori] ?? 'utsatt';

        $geojsonStr = json_encode($geometry);

        // Transform from source SRID to 4326 if needed, and wrap in MultiPolygon
        if ($sourceSrid !== 4326) {
            $geomSql = "ST_Multi(ST_Transform(ST_SetSRID(ST_GeomFromGeoJSON(:geojson), {$sourceSrid}), 4326))";
        } else {
            $geomSql = 'ST_Multi(ST_SetSRID(ST_GeomFromGeoJSON(:geojson), 4326))';
        }

        DB::statement("
            INSERT INTO vulnerability_areas (name, tier, police_region, local_police_area, municipality_code, municipality_name, assessment_year, is_current, metadata, geom, created_at, updated_at)
            VALUES (
                :name, :tier, :region, :lpo, :muni_code, :muni_name, :year, true,
                :metadata,
                {$geomSql},
                NOW(), NOW()
            )
        ", [
            'name' => $name,
            'tier' => $tier,
            'region' => $props['REGION'] ?? null,
            'lpo' => $props['LOKALPOLISOMRADE'] ?? null,
            'muni_code' => isset($props['OMRADESKOD']) ? substr($props['OMRADESKOD'], 0, 4) : null,
            'muni_name' => $props['ORT'] ?? null,
            'year' => $year,
            'metadata' => json_encode([
                'object_id' => $props['OBJECTID'] ?? null,
                'omradeskod' => $props['OMRADESKOD'] ?? null,
                'polisomrade' => $props['POLISOMRADE'] ?? null,
                'aktualitet_start' => $props['AKTUALITET_START'] ?? null,
            ]),
            'geojson' => $geojsonStr,
        ]);
    }

    private function computeDesoMapping(): int
    {
        $this->info('Computing DeSO ↔ vulnerability area spatial overlap...');

        // Clear existing mappings for current areas
        DB::table('deso_vulnerability_mapping')
            ->whereIn('vulnerability_area_id', function ($query) {
                $query->select('id')->from('vulnerability_areas')->where('is_current', true);
            })
            ->delete();

        // Compute intersections
        $inserted = DB::affectingStatement('
            INSERT INTO deso_vulnerability_mapping (deso_code, vulnerability_area_id, overlap_fraction, tier, created_at, updated_at)
            SELECT
                d.deso_code,
                v.id,
                ST_Area(ST_Intersection(d.geom, v.geom)) / NULLIF(ST_Area(d.geom), 0) as overlap_fraction,
                v.tier,
                NOW(),
                NOW()
            FROM deso_areas d
            CROSS JOIN vulnerability_areas v
            WHERE ST_Intersects(d.geom, v.geom)
              AND v.is_current = true
        ');

        $significantOverlap = DB::table('deso_vulnerability_mapping')
            ->join('vulnerability_areas', 'vulnerability_areas.id', '=', 'deso_vulnerability_mapping.vulnerability_area_id')
            ->where('vulnerability_areas.is_current', true)
            ->where('deso_vulnerability_mapping.overlap_fraction', '>=', 0.25)
            ->distinct('deso_vulnerability_mapping.deso_code')
            ->count('deso_vulnerability_mapping.deso_code');

        $this->info("Total intersections: {$inserted}, DeSOs with >=25% overlap: {$significantOverlap}");

        return $significantOverlap;
    }
}
